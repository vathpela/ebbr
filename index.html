
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Embedded Base Boot Requirements (EBBR) Specification unknown-rev documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="embedded-base-boot-requirements-ebbr-specification">
<h1>Embedded Base Boot Requirements (EBBR) Specification<a class="headerlink" href="#embedded-base-boot-requirements-ebbr-specification" title="Permalink to this headline">¶</a></h1>
<p>Copyright © 2017-2018 Arm Limited and Contributors.</p>
<p>This work is licensed under the Creative Commons Attribution-ShareAlike 4.0
International License. To view a copy of this license, visit
<a class="reference external" href="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</a> or send a letter to
Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.</p>
<a class="reference external image-reference" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" class="align-right" src="_images/cc-by-sa-4.0-88x31.png" /></a>
<table border="1" class="docutils" id="id1">
<caption><span class="caption-text">Revision History</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="13%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Date</th>
<th class="head">Issue</th>
<th class="head">Changes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>20 September 2017</td>
<td>0.51</td>
<td>Confidentiality Change, EBBR version 0.51</td>
</tr>
<tr class="row-odd"><td>6 July 2018</td>
<td>0.6-pre1</td>
<td><ul class="first last simple">
<li>Relicense to CC-BY-SA 4.0</li>
<li>Added Devicetree requirements</li>
<li>Added Multiprocessor boot requirements</li>
<li>Transitioned to reStructuredText and GitHub</li>
<li>Added firmware on shared media requirements</li>
<li>RTC is optional</li>
<li>Add constraints on sharing devices between
firmware and OS</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>12 July 2018</td>
<td>0.6</td>
<td><ul class="first last simple">
<li>Response to comments on v0.6-pre1</li>
<li>Add large note on implementation of runtime
modification of non-volatile variables</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>TBD</td>
<td>TBD</td>
<td><ul class="first last simple">
<li>Add AArch32 details</li>
<li>Refactor Runtime Services text after face
to fact meeting at Linaro Connect YVR18</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="toctree-wrapper compound">
<span id="document-chapter1-about"></span><div class="section" id="about-this-document">
<h2>1. About This Document<a class="headerlink" href="#about-this-document" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3>1.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>This Embedded Base Boot Requirements (EBBR) specification defines an interface
between platform firmware and an operating system that is suitable for embedded
platforms.
EBBR compliant platforms present a consistent interface that will boot an EBBR
compliant operating system without any custom tailoring required.
For example, an Arm A-class embedded platform will benefit
from a standard interface that supports features such as secure boot and
firmware update.</p>
<p>This specification defines the base firmware requirements for EBBR compliant platforms.
The requirements in this specification are expected to be minimal yet complete,
while leaving plenty of room for innovations and design details.
This specification is intended to be OS-neutral.</p>
<p>It leverages the prevalent industry standard firmware specification of <a class="reference internal" href="index.html#uefi" id="id1">[UEFI]</a>.</p>
<p>Comments or change requests can be sent to <a class="reference external" href="mailto:arm&#46;ebbr-discuss&#37;&#52;&#48;arm&#46;com">arm<span>&#46;</span>ebbr-discuss<span>&#64;</span>arm<span>&#46;</span>com</a>.</p>
</div>
<div class="section" id="guiding-principles">
<h3>1.2. Guiding Principles<a class="headerlink" href="#guiding-principles" title="Permalink to this headline">¶</a></h3>
<p>EBBR as a specification defines requirements on platforms and operating systems,
but requirements alone don’t provide insight into why the specification is
written the way it is, or what problems it is intended to solve.
Using the assumption that better understanding of the thought process behind
EBBR will result in better implementations, this section is a discussion of the
goals and guiding principle that shaped EBBR.</p>
<p>This section should be considered commentary, and not a formal part of the specification.</p>
<p>EBBR was written as a response to the lack of boot sequence standardization in the embedded system ecosystem.
As embedded systems are becoming more sophisticated and connected,
it is becoming increasingly important for embedded systems to run standard OS
distributions and software stacks, or to have consistent behaviour across a
large deployment of heterogeneous platforms.
However, the lack of consistency between platforms often requires per-platform
customization to get an OS image to boot on multiple platforms.</p>
<p>A large part of this ecosystem is based on U-Boot and Linux.
Vendors have heavy investments in both projects and are not interested in large
scale changes to their firmware architecture.
The challenge for EBBR is to define a set of boot standards that reduce the
amount of custom engineering required, make it possible for OS distributions to
support embedded platforms, while still preserving the firmware stack product
vendors are comfortable with.
Or in simpler terms, EBBR is designed to solve the embedded boot mess by
adding a defined standard (UEFI) to the existing firmware projects (U-Boot).</p>
<p>However, EBBR is a specification, not an implementation.
The goal of EBBR is not to mandate U-Boot and Linux.
Rather, it is to mandate interfaces that can be implemented by any firmware or
OS project, while at the same time work with both Tianocore/EDK2 and U-Boot to
ensure that the EBBR requirements are implemented by both projects.
<a class="footnote-reference" href="#edk2note" id="id2">[1]</a></p>
<table class="docutils footnote" frame="void" id="edk2note" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Tianocore/EDK2 and U-Boot are highlighted here because at the
time of writing these are the two most important firmware projects that
implement UEFI.
Tianocore/EDK2 is a full featured UEFI implementation and so should
automatically be EBBR compliant.
U-Boot is the incumbant firmware project for embedded platforms and has
steadily been adding UEFI compliance since 2016.</td></tr>
</tbody>
</table>
<p>The following guiding principles are used while developing the EBBR specification.</p>
<ul>
<li><p class="first">Be agnostic about ACPI and Devicetree.</p>
<p>EBBR explicitly does not require a specific system description language.
Both Devicetree and ACPI are supported.
The Linux kernel supports both equally well, and so EBBR doesn’t require one
over the other.
However, EBBR does require the system description to be supplied by the
platform, not the OS.
The platform must also conform to the relevant ACPI or DT specifications and
adhere to platform compatibility rules. <a class="footnote-reference" href="#compatrules" id="id3">[2]</a></p>
</li>
</ul>
<table class="docutils footnote" frame="void" id="compatrules" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>It must be acknowledged that at the time of writing this
document, platform compatibility rules for DT platforms are not well defined
or documented.
We the authors recognize that this is a problem and are working to solve it
in parallel with this specification.</td></tr>
</tbody>
</table>
<ul>
<li><p class="first">Focus on the UEFI interface, not a specific codebase</p>
<p>EBBR does not require a specific firmware implementation.
Any firmware project can implement these interfaces.
Neither U-Boot nor Tianocore/EDK2 are required.</p>
</li>
<li><p class="first">Design to be implementable and useful today</p>
<p>The drafting process for EBBR worked closely with U-Boot and Tianocore
developers to ensure that current upstream code will meet the requirements.</p>
</li>
<li><p class="first">Design to be OS independent</p>
<p>This document uses Linux as an example but other OS’s are expected.</p>
</li>
<li><p class="first">Support multiple architectures</p>
<p>Any architecture can implement the EBBR requirements.
Architecture specific requirements will clearly marked as to which
architecture(s) they apply.</p>
</li>
<li><p class="first">Design for common embedded hardware</p>
<p>EBBR support will be implemented on existing developer hardware.
Generally anything that has a near-upstream U-Boot implementation should be
able to implement the EBBR requirements.
EBBR was drafted with readily available hardware in mind, like the
Raspberry Pi and BeagleBone families of boards, and it is applicable for low cost boards (&lt;$10).</p>
</li>
<li><p class="first">Plan to evolve over time</p>
<p>The v1.0 release of EBBR is firmly targeted at existing platforms so that
gaining EBBR compliance may require a firmware update, but will not require
hardware changes for the majority of platforms.</p>
<p>Future EBBR releases will tighten requirements to add features and improve
compatibility, which may affect hardware design choices.
However, EBBR will not retroactively revoke support from previously compliant
platforms.
Instead, new requirements will be clearly documented as being over and above
what was required by a previous release.
Existing platforms will be able to retain compliance with a previous
requirement level.
In turn, OS projects and end users can choose what level of EBBR compliance
is required for their use case.</p>
</li>
</ul>
</div>
<div class="section" id="scope">
<h3>1.3. Scope<a class="headerlink" href="#scope" title="Permalink to this headline">¶</a></h3>
<p>This document defines the boot and runtime services that are expected by an
Operating System or hypervisor, for a device which follows the
UEFI specification <a class="reference internal" href="index.html#uefi" id="id4">[UEFI]</a>.</p>
<p>This specification defines the boot and runtime services for a physical system,
including services that are required for virtualization.
It does not define a standardized abstract virtual machine view for a Guest
Operating System.</p>
<p>This specification is similar to the Arm Server Base Boot Requirements
specification <a class="reference internal" href="index.html#sbbr" id="id5">[SBBR]</a> in that it defines the firmware interface presented to an
operating system.
SBBR is targeted at the server ecosystem and places strict requirements on the
platform to ensure cross vendor interoperability.
EBBR on the other hand allows more flexibility to support embedded designs
which do not fit within the SBBR model.
For example, a platform that isn’t SBBR compliant because the SoC is only
supported using Devicetree could be EBBR compliant, but not SBBR compliant.</p>
<p>By definition, all SBBR compliant systems are also EBBR compliant, but the
converse is not true.</p>
</div>
<div class="section" id="cross-references">
<h3>1.4. Cross References<a class="headerlink" href="#cross-references" title="Permalink to this headline">¶</a></h3>
<p>This document cross-references sources that are listed in the References
section by using the section sign §.</p>
<p>Examples:</p>
<p>UEFI § 6.1 - Reference to the UEFI specification <a class="reference internal" href="index.html#uefi" id="id6">[UEFI]</a> section 6.1</p>
</div>
<div class="section" id="terms-and-abbreviations">
<h3>1.5. Terms and abbreviations<a class="headerlink" href="#terms-and-abbreviations" title="Permalink to this headline">¶</a></h3>
<p>This document uses the following terms and abbreviations.</p>
<dl class="glossary docutils">
<dt id="term-a64">A64</dt>
<dd>The 64-bit Arm instruction set used in AArch64 state.
All A64 instructions are 32 bits.</dd>
<dt id="term-aarch32">AArch32</dt>
<dd>Arm 32-bit architectures. AArch32 is a roll up term referring to all
32-bit versions of the Arm architecture starting at ARMv4.</dd>
<dt id="term-aarch64-state">AArch64 state</dt>
<dd>The Arm 64-bit Execution state that uses 64-bit general purpose
registers, and a 64-bit program counter (PC), Stack Pointer (SP), and
exception link registers (ELR).</dd>
<dt id="term-aarch64">AArch64</dt>
<dd>Execution state provides a single instruction set, A64.</dd>
<dt id="term-efi-loaded-image">EFI Loaded Image</dt>
<dd>An executable image to be run under the UEFI environment,
and which uses boot time services.</dd>
<dt id="term-el0">EL0</dt>
<dd>The lowest Exception level on AArch64. The Exception level that is used to execute
user applications, in Non-secure state.</dd>
<dt id="term-el1">EL1</dt>
<dd>Privileged Exception level on AArch64. The Exception level that is used to execute
Operating Systems, in Non-secure state.</dd>
<dt id="term-el2">EL2</dt>
<dd>Hypervisor Exception level on AArch64. The Exception level that is used to execute
hypervisor code. EL2 is always in Non-secure state.</dd>
<dt id="term-el3">EL3</dt>
<dd>Secure Monitor Exception level on AArch64. The Exception level that is used to
execute Secure Monitor code, which handles the transitions between
Non-secure and Secure states.  EL3 is always in Secure state.</dd>
<dt id="term-logical-unit-lu">Logical Unit (LU)</dt>
<dd>A logical unit (LU) is an externally addressable, independent entity
within a device. In the context of storage, a single device may use
logical units to provide multiple independent storage areas.</dd>
<dt id="term-oem">OEM</dt>
<dd>Original Equipment Manufacturer. In this document, the final device
manufacturer.</dd>
<dt id="term-sip">SiP</dt>
<dd>Silicon Partner. In this document, the silicon manufacturer.</dd>
<dt id="term-uefi">UEFI</dt>
<dd>Unified Extensible Firmware Interface.</dd>
<dt id="term-uefi-boot-services">UEFI Boot Services</dt>
<dd>Functionality that is provided to UEFI Loaded Images during the UEFI boot
process.</dd>
<dt id="term-uefi-runtime-services">UEFI Runtime Services</dt>
<dd>Functionality that is provided to an Operating System after the
ExitBootServices() call.</dd>
</dl>
</div>
</div>
<span id="document-chapter2-uefi"></span><div class="section" id="uefi">
<h2>2. UEFI<a class="headerlink" href="#uefi" title="Permalink to this headline">¶</a></h2>
<p>This chapter discusses specific UEFI implementation details for EBBR compliant
platforms.</p>
<div class="section" id="uefi-version">
<h3>2.1. UEFI Version<a class="headerlink" href="#uefi-version" title="Permalink to this headline">¶</a></h3>
<p>This document uses version 2.7 of the UEFI specification <a class="reference internal" href="index.html#uefi" id="id1">[UEFI]</a>.</p>
</div>
<div class="section" id="uefi-compliance">
<h3>2.2. UEFI Compliance<a class="headerlink" href="#uefi-compliance" title="Permalink to this headline">¶</a></h3>
<p>EBBR compliant platforms shall conform to the requirements in <a class="reference internal" href="index.html#uefi" id="id2">[UEFI]</a> § 2.6,
except where explicit exemptions are provided by this document.</p>
<p>EBBR compliant platforms shall also implement the UEFI services and
protocols that are listed in <a class="reference internal" href="index.html#appendix-uefi-requirements"><span class="std std-ref">APPENDIX A - UEFI Implementation Requirements</span></a> of this
document.</p>
<div class="section" id="block-device-partitioning">
<h4>2.2.1. Block device partitioning<a class="headerlink" href="#block-device-partitioning" title="Permalink to this headline">¶</a></h4>
<p>The system firmware must implement support for MBR, GPT and El Torito partitioning.</p>
</div>
</div>
<div class="section" id="uefi-system-environment-and-configuration">
<h3>2.3. UEFI System Environment and Configuration<a class="headerlink" href="#uefi-system-environment-and-configuration" title="Permalink to this headline">¶</a></h3>
<p>The resident UEFI boot-time environment shall use the highest non-secure
privilege level available.
The exact meaning of this is architecture dependent, as detailed below.</p>
<p>Resident UEFI firmware might target a specific privilege level.
In contrast, UEFI Loaded Images, such as third-party drivers and boot
applications, must not contain any built-in assumptions that they are to be
loaded at a given privilege level during boot time since they can, for example,
legitimately be loaded into either EL1 or EL2 on AArch64.</p>
<div class="section" id="aarch64-exception-levels">
<h4>2.3.1. AArch64 Exception Levels<a class="headerlink" href="#aarch64-exception-levels" title="Permalink to this headline">¶</a></h4>
<p>UEFI shall execute as 64-bit code in AArch64 model at either EL1 or EL2,
depending on whether or not virtualization is used or supported.</p>
<div class="section" id="uefi-boot-at-el2">
<h5>2.3.1.1. UEFI Boot at EL2<a class="headerlink" href="#uefi-boot-at-el2" title="Permalink to this headline">¶</a></h5>
<p>Most systems are expected to boot UEFI at EL2, to allow for the installation of
a hypervisor or a virtualization aware Operating System.</p>
</div>
<div class="section" id="uefi-boot-at-el1">
<h5>2.3.1.2. UEFI Boot at EL1<a class="headerlink" href="#uefi-boot-at-el1" title="Permalink to this headline">¶</a></h5>
<p>Booting of UEFI at EL1 is most likely within a hypervisor hosted Guest
Operating System environment, to allow the subsequent booting of a
UEFI-compliant Operating System.
In this instance, the UEFI boot-time environment can be provided, as a
virtualized service, by the hypervisor and not as part of the host firmware.</p>
</div>
</div>
</div>
<div class="section" id="uefi-boot-services">
<h3>2.4. UEFI Boot Services<a class="headerlink" href="#uefi-boot-services" title="Permalink to this headline">¶</a></h3>
<div class="section" id="memory-map">
<h4>2.4.1. Memory Map<a class="headerlink" href="#memory-map" title="Permalink to this headline">¶</a></h4>
<p>The UEFI environment must provide a system memory map, which must include all
appropriate devices and memories that are required for booting and system
configuration.</p>
<p>All RAM defined by the UEFI memory map must be identity-mapped, which means
that virtual addresses must equal physical addresses.</p>
<p>The default RAM allocated attribute must be EFI_MEMORY_WB.</p>
</div>
<div class="section" id="configuration-tables">
<h4>2.4.2. Configuration Tables<a class="headerlink" href="#configuration-tables" title="Permalink to this headline">¶</a></h4>
<p>A UEFI system that complies with this specification may provide the additional
tables via the EFI Configuration Table.</p>
<p>Compliant systems are required to provide one, but not both, of the following
tables.</p>
<ul class="simple">
<li>An Advanced Configuration and Power Interface <a class="reference internal" href="index.html#acpi" id="id3">[ACPI]</a> table, or</li>
<li>a Devicetree <a class="reference internal" href="index.html#dtspec" id="id4">[DTSPEC]</a> system description</li>
</ul>
<p>As stated above, EBBR systems must not provide both ACPI and Devicetree
tables at the same time.
Systems that support both interfaces must provide a configuration
mechanism to select either ACPI or Devicetree,
and must ensure only the selected interface is provided to the OS loader.</p>
</div>
<div class="section" id="uefi-secure-boot-optional">
<h4>2.4.3. UEFI Secure Boot (Optional)<a class="headerlink" href="#uefi-secure-boot-optional" title="Permalink to this headline">¶</a></h4>
<p>UEFI Secure Boot is optional for this specification.</p>
<p>If Secure Boot is implemented, it must conform to the UEFI specification for Secure Boot. There are no additional
requirements for Secure Boot.</p>
</div>
</div>
<div class="section" id="uefi-runtime-services">
<h3>2.5. UEFI Runtime Services<a class="headerlink" href="#uefi-runtime-services" title="Permalink to this headline">¶</a></h3>
<p>UEFI runtime services exist after the call to ExitBootServices() and are
designed to provide a limited set of persistent services to the platform
Operating System or hypervisor.
Functions contained in EFI_RUNTIME_SERVICES are expected to be available
during both boot services and runtime services.
However, it isn’t always practical for all EFI_RUNTIME_SERVICES functions
to be callable during runtime services due to hardware limitations.
If any EFI_RUNTIME_SERVICES functions are only available during boot services
then firmware shall provide the global <cite>RuntimeServicesAvailable</cite> variable to
indicate which functions are available during runtime services.
Functions that are not available during runtime services shall return
EFI_UNSUPPORTED.</p>
<p>Table :numref:_uefi_runtime_service_requirements details which EFI_RUNTIME_SERVICES
are required to be implemented during boot services and runtime services.</p>
<span id="uefi-runtime-service-requirements"></span><table border="1" class="docutils" id="id8">
<caption><span class="caption-text">EFI_RUNTIME_SERVICES Implementation Requirements</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="51%" />
<col width="22%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">EFI_RUNTIME_SERVICES function</th>
<th class="head">Boot Services</th>
<th class="head">Runtime Services</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_GET_TIME</td>
<td>Optional</td>
<td>Optional</td>
</tr>
<tr class="row-odd"><td>EFI_SET_TIME</td>
<td>Optional</td>
<td>Optional</td>
</tr>
<tr class="row-even"><td>EFI_GET_WAKEUP_TIME</td>
<td>Optional</td>
<td>Optional</td>
</tr>
<tr class="row-odd"><td>EFI_SET_WAKEUP_TIME</td>
<td>Optional</td>
<td>Optional</td>
</tr>
<tr class="row-even"><td>EFI_SET_VIRTUAL_ADDRESS_MAP</td>
<td>N/A</td>
<td>Required</td>
</tr>
<tr class="row-odd"><td>EFI_CONVERT_POINTER</td>
<td>N/A</td>
<td>Required</td>
</tr>
<tr class="row-even"><td>EFI_GET_VARIABLE</td>
<td>Required</td>
<td>Optional</td>
</tr>
<tr class="row-odd"><td>EFI_GET_NEXT_VARIABLE_NAME</td>
<td>Required</td>
<td>Optional</td>
</tr>
<tr class="row-even"><td>EFI_SET_VARIABLE</td>
<td>Required</td>
<td>Optional</td>
</tr>
<tr class="row-odd"><td>EFI_GET_NEXT_HIGH_MONO_COUNT</td>
<td>N/A</td>
<td>Optional</td>
</tr>
<tr class="row-even"><td>EFI_RESET_SYSTEM</td>
<td>Required</td>
<td>Optional</td>
</tr>
<tr class="row-odd"><td>EFI_UPDATE_CAPSULE</td>
<td>Optional</td>
<td>Optional</td>
</tr>
<tr class="row-even"><td>EFI_QUERY_CAPSULE_CAPABILITIES</td>
<td>Optional</td>
<td>Optional</td>
</tr>
<tr class="row-odd"><td>EFI_QUERY_VARIABLE_INFO</td>
<td>Optional</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<div class="section" id="runtime-device-mappings">
<h4>2.5.1. Runtime Device Mappings<a class="headerlink" href="#runtime-device-mappings" title="Permalink to this headline">¶</a></h4>
<p>Firmware shall not create runtime mappings, or perform any runtime IO that will
conflict with device access by the OS.
Normally this means a device may be controlled by firmware, or controlled by
the OS, but not both.
e.g. If firmware attempts to access an eMMC device at runtime then it will
conflict with transactions being performed by the OS.</p>
<p>Devices that are provided to the OS (i.e., via PCIe discovery or ACPI/DT
description) shall not be accessed by firmware at runtime.
Similarly, devices retained by firmware (i.e., not discoverable by the OS)
shall not be accessed by the OS.</p>
<p>Only devices that explicitly support concurrent access by both firmware and an
OS may be mapped at runtime by both firmware and the OS.</p>
<div class="section" id="real-time-clock-rtc">
<h5>2.5.1.1. Real-time Clock (RTC)<a class="headerlink" href="#real-time-clock-rtc" title="Permalink to this headline">¶</a></h5>
<p>Not all embedded systems include an RTC, and even if one is present,
it may not be possible to access the RTC from runtime services.
e.g., The RTC may be on a shared I2C bus which runtime services cannot access
because it will conflict with the OS.</p>
<p>If firmware does not support access to the RTC, then GetTime() and
SetTime() shall return EFI_UNSUPPORTED,
and the OS must use a device driver to control the RTC.</p>
</div>
</div>
<div class="section" id="uefi-reset-and-shutdown">
<h4>2.5.2. UEFI Reset and Shutdown<a class="headerlink" href="#uefi-reset-and-shutdown" title="Permalink to this headline">¶</a></h4>
<p>The UEFI Runtime service ResetSystem() must implement the following commands,
for purposes of power management and system control.</p>
<ul class="simple">
<li>EfiResetCold()</li>
<li>EfiResetShutdown()
* EfiResetShutdown must not reboot the system.</li>
</ul>
<p>If firmware updates are supported through the Runtime Service of
UpdateCapsule(), then ResetSystem() might need to support the following
command:</p>
<ul class="simple">
<li>EfiWarmReset()</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On platforms implementing the Power State Coordination Interface
specification <a class="reference internal" href="index.html#psci" id="id5">[PSCI]</a>, it is still required that EBBR compliant
Operating Systems calls to reset the system will go via Runtime Services
and not directly to PSCI.</p>
</div>
</div>
<div class="section" id="runtime-variable-access">
<h4>2.5.3. Runtime Variable Access<a class="headerlink" href="#runtime-variable-access" title="Permalink to this headline">¶</a></h4>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p>There are many platforms where it is difficult to support SetVariable() for
non-volatile variables because the firmware cannot access storage after
ExitBootServices() is called.
e.g., If firmware accesses an eMMC device directly at runtime, it will
collide with transactions initiated by the OS.
Neither U-Boot nor Tianocore have a solution for accessing shared media for
variable updates. <a class="footnote-reference" href="#opteesupplicant" id="id6">[1]</a></p>
<p>In these platforms SetVariable() calls with the EFI_VARIABLE_NON_VOLATILE
attribute set will work in boot services, but will fail in runtime services.
The <a class="reference internal" href="index.html#uefi" id="id7">[UEFI]</a> specification doesn’t address what to do in this situation.
We need feedback on options before writing this section of EBBR, or making a
proposal to modify UEFI.</p>
<p>We need a solution that communicates to the OS that non-volatile variable
updates are not supported at runtime, and that defines the behaviour when
SetVariable() is called with the EFI_VARIABLE_NON_VOLATILE attribute.</p>
<p>Presumably, the solution will require SetVariable() to return
EFI_INVALID_PARAMETER if called with the EFI_VARIABLE_NON_VOLATILE
attribute, but beyond that there are a number of options:</p>
<ol class="arabic">
<li><p class="first">Clear EFI_VARIABLE_NON_VOLATILE from all variables at ExitBootServices()</p>
<p>If the platform is incapable of updating non-volatile variables from Runtime
Services then it must clear the EFI_VARIABLE_NON_VOLATILE attribute from all
non-volatile variables when ExitBootServices() is called.</p>
<p>An OS can discover that non-volatile variables cannot be updated at
runtime by noticing that the NON_VOLATILE attribute is not set.</p>
</li>
<li><p class="first">Clear all variables at ExitBootServices()</p>
<p>If the platform is incapable of updating non-volatile variables from Runtime
Services then it will clear all variables and return EFI_INVALID_PARAMETER
on all calls to SetVariable().</p>
<p>SUSE in particular currently uses this behaviour to decide whether or not
to treat the ESP as removable media.</p>
</li>
<li><p class="first">Advertise that SetVariable() doesn’t work at runtime with another variable</p>
<p>Platforms can check another variable to determine if they have this quirk,
perhaps by adding a new BootOptionSupport flag.</p>
</li>
</ol>
<p>This is not a complete list, and other options can still be proposed. We’re
looking for feedback on what would be most faithful to the UEFI spec, and
would work for the OS distributions before filling out this section of the
specification.</p>
<p class="last">Comments can be sent to the <a class="reference external" href="mailto:boot-architecture&#37;&#52;&#48;lists&#46;linaro&#46;org">boot-architecture<span>&#64;</span>lists<span>&#46;</span>linaro<span>&#46;</span>org</a> mailing list.</p>
</div>
<table class="docutils footnote" frame="void" id="opteesupplicant" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[1]</a></td><td><p class="first">It is worth noting that OP-TEE has a similar problem
regarding secure storage.
OP-TEE’s chosen solution is to rely on an OS supplicant agent to perform
storage operations on behalf of OP-TEE.
The same solution may be applicable to solving the UEFI non-volatile
variable problem, but that approach is also not entirely UEFI compliant
because it requires additional OS support to work.</p>
<p class="last"><a class="reference external" href="https://github.com/OP-TEE/optee_os/blob/master/documentation/secure_storage.md">https://github.com/OP-TEE/optee_os/blob/master/documentation/secure_storage.md</a></p>
</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<span id="document-chapter3-secureworld"></span><div class="section" id="priviledged-or-secure-firmware">
<h2>3. Priviledged or Secure Firmware<a class="headerlink" href="#priviledged-or-secure-firmware" title="Permalink to this headline">¶</a></h2>
<div class="section" id="aarch32-multiprocessor-startup-protocol">
<h3>3.1. AArch32 Multiprocessor Startup Protocol<a class="headerlink" href="#aarch32-multiprocessor-startup-protocol" title="Permalink to this headline">¶</a></h3>
<p>There is no standard multiprocessor startup or CPU power management mechanism
for ARMv7 and earlier platforms.
The OS is expected to use platform specific drivers for CPU power management.
Firmware must advertize the CPU power management mechanism in the Devicetree
system description or the ACPI tables so that the OS can enable the correct
driver.
At ExitBootServices() time, all secondary CPUs must be parked or powered off.</p>
</div>
<div class="section" id="aarch64-multiprocessor-startup-protocol">
<h3>3.2. AArch64 Multiprocessor Startup Protocol<a class="headerlink" href="#aarch64-multiprocessor-startup-protocol" title="Permalink to this headline">¶</a></h3>
<p>On AArch64 platforms, Firmware resident in Trustzone EL3 must implement and
conform to the Power State Coordination Interface specification <a class="reference internal" href="index.html#psci" id="id1">[PSCI]</a>.</p>
<p>Platforms without EL3 must implement one of:</p>
<ul class="simple">
<li>PSCI at EL2 (leaving only EL1 available to an operating system)</li>
<li>Linux AArch64 spin tables <a class="reference internal" href="index.html#linuxa64boot" id="id2">[LINUXA64BOOT]</a> (Devicetree only)</li>
</ul>
<p>However, the spin table protocol is strongly discouraged.
Future versions of this specification will only allow PSCI, and PSCI should
be implemented in all new designs.</p>
</div>
</div>
<span id="document-chapter4-firmware-media"></span><div class="section" id="firmware-storage">
<h2>4. Firmware Storage<a class="headerlink" href="#firmware-storage" title="Permalink to this headline">¶</a></h2>
<p>In general, EBBR compliant platforms should use dedicated storage for boot
firmware images and data,
independent of the storage used for OS partitions and the EFI System Partition
(ESP).
This could be a physically separate device (e.g. SPI flash),
or a dedicated logical unit (LU) within a device
(e.g. eMMC boot partition, <a class="footnote-reference" href="#emmcbootpartition" id="id1">[1]</a>
or UFS boot LU <a class="footnote-reference" href="#logicalunitnote" id="id2">[2]</a>).</p>
<p>However, many embedded systems have size, cost, or implementation
constraints that make separate firmware storage unfeasible.
On such systems, firmware and the OS reside in the same storage device.
Care must be taken to ensure firmware kept in normal storage does not
conflict with normal usage of the media by an OS.</p>
<ul class="simple">
<li>Firmware must be stored on the media in a way that does not conflict
with normal partitioning and usage by the operating system.</li>
<li>Normal operation of the OS must not interfere with firmware files.</li>
<li>Firmware needs a method to modify variable storage at runtime while the
OS controls access to the device. <a class="footnote-reference" href="#luvariables" id="id3">[3]</a></li>
</ul>
<table class="docutils footnote" frame="void" id="emmcbootpartition" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Watch out for the ambiguity of the word ‘partition’.
In most of this document, a ‘partition’ is a contiguous region of a block
device as described by a GPT or MBR partition table,
but eMMC devices also provide a dedicated ‘boot partition’ that is addressed
separately from the main storage region, and does not appear in the
partition table.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="logicalunitnote" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>For the purposes of this document, logical units are
treated as independent storage devices, each with their own GPT or MBR
partition table.
A platform that uses one LU for firmware, and another LU for OS partitions
and the ESP is considered to be using dedicated firmware storage.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="luvariables" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Runtime access to firmware data may still be an issue when
firmware is stored in a dedicated LU, simply because the OS remains in
control of the storage device command stream. If firmware doesn’t have
a dedicated channel to the storage device, then the OS must proxy all
runtime storage IO.</td></tr>
</tbody>
</table>
<div class="section" id="partitioning-of-shared-storage">
<h3>4.1. Partitioning of Shared Storage<a class="headerlink" href="#partitioning-of-shared-storage" title="Permalink to this headline">¶</a></h3>
<p>A shared storage device shall use GPT partitioning unless it is incompatible
with the platform boot sequence.
In which case, MBR partitioning shall be used. <a class="footnote-reference" href="#mbrreqexample" id="id4">[4]</a></p>
<table class="docutils footnote" frame="void" id="mbrreqexample" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>For example, if the boot ROM doesn’t understand GPT
partitioning, and will only work with an MBR, then the storage must be
partitioned using an MBR.</td></tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>MBR partitioning is deprecated and only included for legacy support.
All new platforms are expected to use GPT partitioning.
GPT partitioning supports a much larger number of partitions, and
has built in resiliency.</p>
<p class="last">A future issue of this specification will remove the MBR allowance.</p>
</div>
<p>Firmware images and data in shared storage should be contained
in partitions described by the GPT or MBR.
The platform should locate firmware by searching the partition table for
the partition(s) containing firmware.</p>
<p>However, some SoCs load firmware from a fixed offset into the storage media.
In this case, to protect against partitioning tools overwriting firmware, the
firmware image shall either reside entirely within the first 1MiB of storage,
or should be covered by a protective partition entry in the partition table as
described in sections <a class="reference internal" href="#section-gpt-parts"><span class="std std-ref">GPT partitioning</span></a> and <a class="reference internal" href="#section-mbr-parts"><span class="std std-ref">MBR partitioning</span></a>.</p>
<p>Automatic partitioning tools (e.g. an OS installer) must not create
partitions within the first 1MiB of storage, or delete, move, or modify
protective partition entries.
Manual partitioning tools should provide warnings when modifying
protective partitions or creating partitions within the first 1MiB.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Fixed offsets to firmware data is supported only for legacy reasons.
All new platforms are expected to use partitions to locate firmware files.</p>
<p class="last">A future issues of this specification will disallow the use of fixed
offsets.</p>
</div>
<div class="section" id="gpt-partitioning">
<span id="section-gpt-parts"></span><h4>4.1.1. GPT partitioning<a class="headerlink" href="#gpt-partitioning" title="Permalink to this headline">¶</a></h4>
<p>The partition table must strictly conform to the UEFI specification and include
a protective MBR authored exactly as described in <a class="reference internal" href="index.html#uefi" id="id5">[UEFI]</a> § 5 (hybrid
partitioning schemes are not permitted).</p>
<p>Protective partitions must have the Platform Required Attribute Flag set.</p>
<div class="section" id="mbr-partitioning">
<span id="section-mbr-parts"></span><h5>4.1.1.1. MBR partitioning<a class="headerlink" href="#mbr-partitioning" title="Permalink to this headline">¶</a></h5>
<p>Protective partitions should have a partition type of 0xF8 unless some
immutable feature of the platform makes this impossible.</p>
</div>
</div>
</div>
<div class="section" id="firmware-partition-filesystem">
<span id="section-fw-partition-fs"></span><h3>4.2. Firmware Partition Filesystem<a class="headerlink" href="#firmware-partition-filesystem" title="Permalink to this headline">¶</a></h3>
<p>Where possible, firmware images and data should be stored in a filesystem.
Firmware can be stored either in a dedicated firmware partition,
or in certain circumstances in the UEFI System Partition (ESP).
Using a filesystem makes it simpler to manage multiple firmware files and
makes it possible for a single disk image to contain firmware for multiple
platforms.</p>
<p>When firmware is stored in the ESP, the ESP should contain a partition named
<code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code> in the root directory,
and all firmware images and data should be stored in platform vendor
subdirectories under <code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code>.</p>
<p>Dedicated firmware partitions should be formatted with a FAT
filesystem as defined by the UEFI specification.
Dedicated firmware partitions should use the same <code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code> directory
hierarchy.
OS tools shall ignore dedicated firmware partitions,
and shall not attempt to use a dedicated firmware partition as an ESP.</p>
<p>Vendors may choose their own subdirectory name under <code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code>,
but shall choose names the do not conflict with other vendors.
Normally the vendor name will be the name of the SoC vendor, because the
firmware directory name will be hard coded in the SoC’s boot ROM.
Vendors are recommended to use their Devicetree vendor prefix as their
vendor subdirectory name.</p>
<p>Vendors are free to decide how to structure subdirectories under their
own vendor directory, but they shall use a naming convention that allows
multiple SoCs to be supported in the same filesystem.</p>
<p>For example, a vendor named Acme with two SoCs, AM100 &amp; AM300, could
choose to use the SoC part number as a subdirectory in the firmware path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">FIRMWARE</span>
  <span class="o">/</span><span class="n">ACME</span>
    <span class="o">/</span><span class="n">AM100</span>
      <span class="n">fw</span><span class="o">.</span><span class="n">img</span>
    <span class="o">/</span><span class="n">AM300</span>
      <span class="n">fw</span><span class="o">.</span><span class="n">img</span>
</pre></div>
</div>
<p>It is also recommended for dedicated firmware partitions to use the
<code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code> file hierarchy.</p>
<p>The following is a sample directory structure for firmware files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">FIRMWARE</span>
  <span class="o">/&lt;</span><span class="n">Vendor</span> <span class="mi">1</span> <span class="n">Directory</span><span class="o">&gt;</span>
     <span class="o">/&lt;</span><span class="n">SoC</span> <span class="n">A</span> <span class="n">Directory</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">Firmware</span> <span class="n">image</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">Firmware</span> <span class="n">data</span><span class="o">&gt;</span>
     <span class="o">/&lt;</span><span class="n">SoC</span> <span class="n">B</span> <span class="n">Directory</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">Firmware</span> <span class="n">image</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">Firmware</span> <span class="n">data</span><span class="o">&gt;</span>
  <span class="o">/&lt;</span><span class="n">Vendor</span> <span class="mi">2</span> <span class="n">Directory</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">Common</span> <span class="n">Firmware</span> <span class="n">image</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">Common</span> <span class="n">Firmware</span> <span class="n">data</span><span class="o">&gt;</span>
  <span class="o">/&lt;</span><span class="n">Vendor</span> <span class="mi">3</span> <span class="n">Directory</span><span class="o">&gt;</span>
     <span class="o">/&lt;</span><span class="n">SoC</span> <span class="n">E</span> <span class="n">Directory</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">Firmware</span> <span class="n">image</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Operating systems and installers should not manipulate any files in the
<code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code> hierarchy during normal operation.</p>
<p>The sections below discuss the requirements when using both fixed and
removable storage.
However, it should be noted that the recommended behaviour of firmware
should be identical regardless of storage type.
In both cases, the recommended boot sequence is to first search for firmware
in a dedicated firmware partition, and second search for firmware in the
ESP.
The only difference between fixed and removable storage is the recommended
factory settings for the platform.</p>
<div class="section" id="fixed-shared-storage">
<h4>4.2.1. Fixed Shared Storage<a class="headerlink" href="#fixed-shared-storage" title="Permalink to this headline">¶</a></h4>
<p>Fixed storage is storage that is permanently attached to the platform,
and cannot be moved between systems.
eMMC and Universal Flash Storage (UFS) device are often used as
shared fixed storage for both firmware and the OS.</p>
<p>Where possible, it is prefered for the system to boot from a dedicated boot
region on media that provides one (e.g., eMMC) that is sufficiently large.
Otherwise, the platform storage should be pre-formatted in the factory with
a partition table, a dedicated firmware partition, and firmware binaries
installed.</p>
<p>Operating systems must not use the dedicated firmware partition for installing
EFI applications including, but not limited to, the OS loader and OS specific
files. Instead, a normal ESP should be created.
OS partitioning tools must take care not to modify or delete dedicated
firmware partitions.</p>
</div>
<div class="section" id="removable-shared-storage">
<h4>4.2.2. Removable Shared Storage<a class="headerlink" href="#removable-shared-storage" title="Permalink to this headline">¶</a></h4>
<p>Removable storage is any media that can be physically removed from
the system and moved to another machine as part of normal operation
(e.g., SD cards, USB thumb drives, and CDs).</p>
<p>There are two primary scenarios for storing firmware on removable media.</p>
<ol class="arabic simple">
<li>Platforms that only have removable media (e.g., The Raspberry Pi has an
SD card slot, but no fixed storage).</li>
<li>Recovery when on-board firmware has been corrupted. If firmware on
fixed media has been corrupted, some platforms support loading firmware
from removable media which can then be used to recover the platform.</li>
</ol>
<p>In both cases, it is desirable to start with a stock OS boot image,
copy it to the media (SD or USB), and then add the necessary firmware files
to make the platform bootable.
Typically, OS boot images won’t include a dedicated firmware partition,
and it is inconvenient to repartition the media to add one.
It is simpler and easier for the user if they are able to copy
the required firmware files into the <code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code> directory tree on the ESP
using the basic file manager tools provided by all desktop operating systems.</p>
<p>On removable media, firmware should be stored in the ESP under the
<code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code> directory structure as described in
<a class="reference internal" href="#section-fw-partition-fs"><span class="std std-ref">Firmware Partition Filesystem</span></a>.
Platform vendors should support their platform by providing a single
.zip file that places all the required firmware files in the correct
locations when extracted in the ESP <code class="docutils literal notranslate"><span class="pre">/FIRMWARE</span></code> directory.
For simplicity sake, it is expected the same .zip file will recover the
firmware files in a dedicated firmware partition.</p>
</div>
</div>
</div>
<span id="document-appendix-a-uefi-features"></span><div class="section" id="appendix-a-uefi-implementation-requirements">
<span id="appendix-uefi-requirements"></span><h2>5. APPENDIX A - UEFI Implementation Requirements<a class="headerlink" href="#appendix-a-uefi-implementation-requirements" title="Permalink to this headline">¶</a></h2>
<div class="section" id="required-boot-services">
<h3>5.1. Required Boot Services<a class="headerlink" href="#required-boot-services" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_RAISE_TPL</td>
<td>7.1</td>
</tr>
<tr class="row-odd"><td>EFI_RESTORE_TPL</td>
<td>7.1</td>
</tr>
<tr class="row-even"><td>EFI_ALLOCATE_PAGES</td>
<td>7.2</td>
</tr>
<tr class="row-odd"><td>EFI_FREE_PAGES</td>
<td>7.2</td>
</tr>
<tr class="row-even"><td>EFI_GET_MEMORY_MAP</td>
<td>7.2</td>
</tr>
<tr class="row-odd"><td>EFI_ALLOCATE_POOL</td>
<td>7.2</td>
</tr>
<tr class="row-even"><td>EFI_FREE_POOL</td>
<td>7.2</td>
</tr>
<tr class="row-odd"><td>EFI_CREATE_EVENT</td>
<td>7.1</td>
</tr>
<tr class="row-even"><td>EFI_SET_TIMER</td>
<td>7.1</td>
</tr>
<tr class="row-odd"><td>EFI_WAIT_FOR_EVENT</td>
<td>7.1</td>
</tr>
<tr class="row-even"><td>EFI_SIGNAL_EVENT</td>
<td>7.1</td>
</tr>
<tr class="row-odd"><td>EFI_CLOSE_EVENT</td>
<td>7.1</td>
</tr>
<tr class="row-even"><td>EFI_INSTALL_PROTOCOL_INTERFACE</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_REINSTALL_PROTOCOL_INTERFACE</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_UNINSTALL_PROTOCOL_INTERFACE</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_HANDLE_PROTOCOL</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_REGISTER_PROTOCOL_NOTIFY</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_LOCATE_HANDLE</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_LOCATE_PROTOCOL</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_LOCATE_DEVICE_PATH</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_INSTALL_CONFIGURATION_TABLE</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_IMAGE_LOAD</td>
<td>7.4</td>
</tr>
<tr class="row-even"><td>EFI_IMAGE_START</td>
<td>7.4</td>
</tr>
<tr class="row-odd"><td>EFI_EXIT</td>
<td>7.4</td>
</tr>
<tr class="row-even"><td>EFI_IMAGE_UNLOAD</td>
<td>7.4</td>
</tr>
<tr class="row-odd"><td>EFI_EXIT_BOOT_SERVICES</td>
<td>7.4</td>
</tr>
<tr class="row-even"><td>EFI_GET_NEXT_MONOTONIC_COUNT</td>
<td>7.5</td>
</tr>
<tr class="row-odd"><td>EFI_STALL</td>
<td>7.5</td>
</tr>
<tr class="row-even"><td>EFI_SET_WATCHDOG_TIMER</td>
<td>7.5</td>
</tr>
<tr class="row-odd"><td>EFI_CONNECT_CONTROLLER</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_DISCONNECT_CONTROLLER</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_OPEN_PROTOCOL</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_CLOSE_PROTOCOL</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_OPEN_PROTOCOL_INFORMATION</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_PROTOCOLS_PER_HANDLE</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_LOCATE_HANDLE_BUFFER</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_LOCATE_PROTOCOL</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES</td>
<td>7.3</td>
</tr>
<tr class="row-even"><td>EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES</td>
<td>7.3</td>
</tr>
<tr class="row-odd"><td>EFI_CALCULATE_CRC32</td>
<td>7.5</td>
</tr>
<tr class="row-even"><td>EFI_COPY_MEM</td>
<td>7.5</td>
</tr>
<tr class="row-odd"><td>EFI_SET_MEM</td>
<td>7.5</td>
</tr>
<tr class="row-even"><td>EFI_CREATE_EVENT_EX</td>
<td>7.5</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="required-uefi-protocols">
<h3>5.2. Required UEFI Protocols<a class="headerlink" href="#required-uefi-protocols" title="Permalink to this headline">¶</a></h3>
<div class="section" id="core-uefi-protocols">
<h4>5.2.1. Core UEFI Protocols<a class="headerlink" href="#core-uefi-protocols" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_LOADED_IMAGE_PROTOCOL</td>
<td>9.1</td>
</tr>
<tr class="row-odd"><td>EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL</td>
<td>9.2</td>
</tr>
<tr class="row-even"><td>EFI_DECOMPRESS_PROTOCOL</td>
<td>19.5</td>
</tr>
<tr class="row-odd"><td>EFI_DEVICE_PATH_PROTOCOL</td>
<td>10.2</td>
</tr>
<tr class="row-even"><td>EFI_DEVICE_PATH_UTILITIES_PROTOCOL</td>
<td>10.3</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="media-i-o-protocols">
<h4>5.2.2. Media I/O Protocols<a class="headerlink" href="#media-i-o-protocols" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_LOAD_FILE2_PROTOCOL</td>
<td>13.2</td>
</tr>
<tr class="row-odd"><td>EFI_SIMPLE_FILE_SYSTEM_PROTOCOL</td>
<td>13.4</td>
</tr>
<tr class="row-even"><td>EFI_FILE_PROTOCOL</td>
<td>13.5</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="console-protocols">
<h4>5.2.3. Console Protocols<a class="headerlink" href="#console-protocols" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_SIMPLE_TEXT_INPUT_PROTOCOL</td>
<td>12.2</td>
</tr>
<tr class="row-odd"><td>EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL</td>
<td>12.3</td>
</tr>
<tr class="row-even"><td>EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</td>
<td>12.4</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="driver-configuration-protocols">
<h4>5.2.4. Driver Configuration Protocols<a class="headerlink" href="#driver-configuration-protocols" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_HII_DATABASE_PROTOCOL</td>
<td>33.4</td>
</tr>
<tr class="row-odd"><td>EFI_HII_STRING_PROTOCOL</td>
<td>33.4</td>
</tr>
<tr class="row-even"><td>EFI_HII_CONFIG_ROUTING_PROTOCOL</td>
<td>33.4</td>
</tr>
<tr class="row-odd"><td>EFI_HII_CONFIG_ACCESS_PROTOCOL</td>
<td>33.4</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="optional-uefi-protocols">
<h3>5.3. Optional UEFI Protocols<a class="headerlink" href="#optional-uefi-protocols" title="Permalink to this headline">¶</a></h3>
<div class="section" id="basic-networking-support">
<h4>5.3.1. Basic Networking Support<a class="headerlink" href="#basic-networking-support" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_SIMPLE_NETWORK_PROTOCOL</td>
<td>24.1</td>
</tr>
<tr class="row-odd"><td>EFI_MANAGED_NETWORK_PROTOCOL</td>
<td>25.1</td>
</tr>
<tr class="row-even"><td>EFI_MANAGED_NETWORK_SERVICE_BINDING_PROTOCOL</td>
<td>25.1</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Networking services are optional on platforms that do not support
networking.</p>
</div>
</div>
<div class="section" id="network-boot-protocols">
<h4>5.3.2. Network Boot Protocols<a class="headerlink" href="#network-boot-protocols" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_PXE_BASE_CODE_PROTOCOL</td>
<td>24.3</td>
</tr>
<tr class="row-odd"><td>EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL</td>
<td>24.4</td>
</tr>
<tr class="row-even"><td>EFI_BIS_PROTOCOL</td>
<td>24.5</td>
</tr>
<tr class="row-odd"><td>EFI_MTFTP4_PROTOCOL</td>
<td>30.3</td>
</tr>
<tr class="row-even"><td>EFI_MTFTP6_PROTOCOL</td>
<td>30.4</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">EFI_BIS_PROTOCOL is optional on machines that do not support Secure
Boot.</p>
</div>
</div>
<div class="section" id="ipv4-network-support">
<h4>5.3.3. IPV4 Network Support<a class="headerlink" href="#ipv4-network-support" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_ARP_PROTOCOL</td>
<td>29.1</td>
</tr>
<tr class="row-odd"><td>EFI_ARP_SERVICE_BINDING_PROTOCOL</td>
<td>29.1</td>
</tr>
<tr class="row-even"><td>EFI_DHCP4_SERVICE_BINDING_PROTOCOL</td>
<td>29.2</td>
</tr>
<tr class="row-odd"><td>EFI_DHCP4_PROTOCOL</td>
<td>29.2</td>
</tr>
<tr class="row-even"><td>EFI_TCP4_PROTOCOL</td>
<td>28.1.2</td>
</tr>
<tr class="row-odd"><td>EFI_TCP4_SERVICE_BINDING_PROTOCOL</td>
<td>28.1.1</td>
</tr>
<tr class="row-even"><td>EFI_IP4_SERVICE_BINDING_PROTOCOL</td>
<td>28.3.1</td>
</tr>
<tr class="row-odd"><td>EFI_IP4_CONFIG2_PROTOCOL</td>
<td>28.5</td>
</tr>
<tr class="row-even"><td>EFI_UDP4_PROTOCOL</td>
<td>30.1.2</td>
</tr>
<tr class="row-odd"><td>EFI_UDP4_SERVICE_BINDING_PROTOCOL</td>
<td>30.1.1</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Networking services are optional on platforms that do not support
networking.</p>
</div>
</div>
<div class="section" id="ipv6-network-support">
<h4>5.3.4. IPV6 Network Support<a class="headerlink" href="#ipv6-network-support" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_DHCP6_PROTOCOL</td>
<td>29.3.2</td>
</tr>
<tr class="row-odd"><td>EFI_DHCP6_SERVICE_BINDING_PROTOCOL</td>
<td>29.3.1</td>
</tr>
<tr class="row-even"><td>EFI_TCP6_PROTOCOL</td>
<td>28.2.2</td>
</tr>
<tr class="row-odd"><td>EFI_TCP6_SERVICE_BINDING_PROTOCOL</td>
<td>28.2.1</td>
</tr>
<tr class="row-even"><td>EFI_IP6_SERVICE_BINDING_PROTOCOL</td>
<td>28.6.1</td>
</tr>
<tr class="row-odd"><td>EFI_IP6_CONFIG_PROTOCOL</td>
<td>28.7</td>
</tr>
<tr class="row-even"><td>EFI_UDP6_PROTOCOL</td>
<td>30.2.2</td>
</tr>
<tr class="row-odd"><td>EFI_UDP6_SERVICE_BINDING_PROTOCOL</td>
<td>30.2.1</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Networking services are optional on platforms that do not support
networking.</p>
</div>
</div>
<div class="section" id="vlan-protocols">
<h4>5.3.5. VLAN Protocols<a class="headerlink" href="#vlan-protocols" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_VLAN_CONFIG_PROTOCOL</td>
<td>27.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="iscsi-protocols">
<h4>5.3.6. iSCSI Protocols<a class="headerlink" href="#iscsi-protocols" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="88%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Service</th>
<th class="head">UEFI §</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EFI_ISCSI_INITIATOR_NAME_PROTOCOL</td>
<td>16.2</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Support for iSCSI is only required on machines that lack persistent
storage, such as a, HDD. This configuration is intended for thin clients and
compute-only nodes</p>
</div>
</div>
</div>
</div>
<span id="document-references"></span><table class="docutils citation" frame="void" id="acpi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[ACPI]</td><td><a class="reference external" href="http://www.uefi.org/sites/default/files/resources/ACPI%206_2_A_Sept29.pdf">Advanced Configuration and Power Interface specification v6.2A</a>,
September 2017, <a class="reference external" href="http://www.uefi.org">UEFI Forum</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dtspec" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[DTSPEC]</td><td><a class="reference external" href="https://github.com/devicetree-org/devicetree-specification/releases/tag/v0.2">Devicetree specification v0.2</a>,
<a class="reference external" href="https://devicetree.org">Devicetree.org</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="linuxa64boot" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[LINUXA64BOOT]</td><td><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/tree/Documentation/arm64/booting.txt">Linux Documentation/arm64/booting.txt</a>,
Linux kernel</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="psci" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[PSCI]</td><td><a class="reference external" href="https://static.docs.arm.com/den0022/c/DEN0022C_Power_State_Coordination_Interface.pdf">Power State Coordination Interface Issue C (PSCI v1.0)</a>
30 January 2015, <a class="reference external" href="http://arm.com">Arm Limited</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="sbbr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[SBBR]</td><td><a class="reference external" href="https://static.docs.arm.com/den0044/b/DEN0044B_Server_Base_Boot_Requirements.pdf">Arm Server Base Boot Requirements specification Issue B (v1.0)</a>
8 March 2016, <a class="reference external" href="http://arm.com">Arm Limited</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="uefi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[UEFI]</td><td><a class="reference external" href="http://www.uefi.org/sites/default/files/resources/UEFI%20Spec%202_7_A%20Sept%206.pdf">Unified Extensable Firmware Interface Specification v2.7A</a>,
August 2017, <a class="reference external" href="http://www.uefi.org">UEFI Forum</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html#document-index">Embedded Base Boot Requirements (EBBR) Specification</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapter1-about">1. About This Document</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapter2-uefi">2. UEFI</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapter3-secureworld">3. Priviledged or Secure Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-chapter4-firmware-media">4. Firmware Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-appendix-a-uefi-features">5. APPENDIX A - UEFI Implementation Requirements</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html#document-index">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018 Arm Limited and Contributors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>